<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<head>
  <title>GenDoc Documentation
  </title>
  <link rel='stylesheet' type='text/css' href='simple.css' />
</head>
<html>

<h1>CheckL</h1>

<p>Why write programs in Common Lisp but tests like Java?</p>

<p>My workflow for writing Common Lisp tends to be like this:</p>

<ul>
<li>Write a bit of lisp, perhaps a function, class, or structure</li>
<li>Write a snippet in a scratch buffer to test</li>
<li>Fix if necessary and repeat</li>
</ul>

<p>Testing is already inherent in this process, all we need is a little
bit of Common Lisp magic to take advantage of it.  Thus, CheckL:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">+ 1 1</span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span> <span class="comment">;; =&gt; 2<br>
</span><br>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">+ 1 2</span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span><br><br>
<span class="comment">; &nbsp;&nbsp;&nbsp;&nbsp;|<br>
</span><span class="comment">; &nbsp;&nbsp;&nbsp;&nbsp;v<br>
</span><span class="comment">; <br>
</span><span class="comment">; Result 0 has changed: 3<br>
</span><span class="comment">; Previous result: 2<br>
</span><span class="comment">; &nbsp;&nbsp;&nbsp;[Condition of type CHECKL::RESULT-ERROR]<br>
</span><span class="comment">; <br>
</span><span class="comment">; Restarts:<br>
</span><span class="comment">; &nbsp;0: [USE-NEW-VALUE] The new value is correct, use it from now on.<br>
</span><span class="comment">; &nbsp;1: [SKIP-TEST] Skip this, leaving the old value, but continue testing<br>
</span><span class="comment">; &nbsp;2: [RETRY] Retry SLIME interactive evaluation request.<br>
</span><span class="comment">; &nbsp;3: [*ABORT] Return to SLIME's top level.<br>
</span><span class="comment">; &nbsp;4: [TERMINATE-THREAD] Terminate this thread (#&lt;THREAD "worker" RUNNING {100586AB13}&gt;)</span></div></code>

<h1>Usage</h1>

<h2>Tests</h2>

<p>Presumably you already write code to test.  Possibly you even write
something like this, evaluating it and manually checking the result:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">progn</span></i><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">function-1 ...</span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">function-2 ...</span>)</span></span>)</span></div></code>

<p>With CheckL, you don't really have to change much.  Your <code>PROGN</code>
becomes a <code>CHECK ()</code> and you run it.  CheckL notifies you if something
changes!</p>

<p>Results are compared with <code>CHECKL:RESULT-EQUALP</code>.  This defaults to
<code>CL:EQUALP</code>.  Defining it for other things may be useful.</p>

<p>For very long values, it may be helpful to print them:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"><span class="keyword">:output-p</span> t</span>)</span> <span class="paren2">(<span class="code">some-very-long-result</span>)</span></span>)</span> =&gt; ...</div></code>

<p>If you make changes to the test, it becomes another test:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">+ 1 1</span>)</span></span>)</span><br>
<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">;; =&gt; 2<br>
</span><span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">1- <span class="paren3">(<span class="code">foo</span>)</span></span>)</span></span>)</span> <span class="comment">;; =&gt; 1</span></div></code>

<p>However, if you name it before you change it, it'll always compare
against the same list:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span> <span class="comment">;; =&gt; 2<br>
</span><br>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">+ 1 3</span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:two</span></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span> <span class="comment">;; =&gt; Error!</span></div></code>

<p>In this case, the old &quot;anonymous&quot; test (actually identified by the
body of the test) is now named <code>:two</code>.  Making changes to the test
will alter the same test, now named <code>:two</code>, and compare against prior
results.</p>

<p>Finally, you might want to check more than one thing in a single
<code>CHECK</code>.  You can do this with <code>RESULTS</code> (which is similar but not
identical to <code>VALUES</code>; see below):</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">+ 1 1</span>)</span><br>
<span class="paren2">(<span class="code"><i><span class="symbol">defun</span></i> bar <span class="paren3">(<span class="code"></span>)</span> <span class="paren3">(<span class="code">- 1 1</span>)</span></span>)</span><br><br>
<span class="paren2">(<span class="code">check <span class="paren3">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:two</span></span>)</span><br>&nbsp;&nbsp;<span class="paren3">(<span class="code">results <span class="paren4">(<span class="code">foo</span>)</span> <span class="paren4">(<span class="code">bar</span>)</span></span>)</span></span>)</span> <span class="comment">;; =&gt; 2, 0<br>
</span><br>
<span class="paren2">(<span class="code"><i><span class="symbol">defun</span></i> bar <span class="paren3">(<span class="code"></span>)</span> <span class="paren3">(<span class="code">foo</span>)</span></span>)</span><br><br>
<span class="paren2">(<span class="code">check <span class="paren3">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:two</span></span>)</span><br>&nbsp;&nbsp;<span class="paren3">(<span class="code">results <span class="paren4">(<span class="code">foo</span>)</span> <span class="paren4">(<span class="code">bar</span>)</span></span>)</span></span>)</span> <span class="comment">;; =&gt; Error!</span></span></span></div></code>

<p>Or, if you want to run one or more tests:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">run <span class="keyword">:two</span> ...</span>)</span></div></code>

<h2>Results</h2>

<p><code>RESULTS</code> is much like <code>VALUES</code>; in fact, you can use <code>VALUES</code> instead
of <code>RESULTS</code>.  However, <code>RESULTS</code> calls <code>RESULT-TRANSLATE</code> on each
form as it occurs.  By default, this copies structures and sequences,
and marshals/unmarshals standard-objects.</p>

<p>With <code>VALUES</code>, the following will likely not be what you want:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i> thing <span class="paren2">(<span class="code">x 0</span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> incr-thing <span class="paren2">(<span class="code">thing</span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">incf <span class="paren3">(<span class="code">thing-x thing</span>)</span></span>)</span><br>&nbsp;&nbsp;thing</span>)</span><br><br>
<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:incr-thing</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">thing <span class="paren5">(<span class="code">make-thing</span>)</span></span>)</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class="code">values<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="code">incr-thing thing</span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="code">incr-thing thing</span>)</span></span>)</span></span>)</span></span>)</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">;; =&gt; #S(.. 2), #S(.. 2), #S(.. 2)</span></div></code>

<p>However, with <code>RESULTS</code>, we get a copy each time:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:incr-thing</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">thing <span class="paren5">(<span class="code">make-thing</span>)</span></span>)</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class="code">results<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="code">incr-thing thing</span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="code">incr-thing thing</span>)</span></span>)</span></span>)</span></span>)</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">;; =&gt; #S(.. 0), #S(.. 1), #S(.. 2)</span></div></code>

<p>Additionally, it can be very useful to override <code>RESULT-TRANSLATE</code>,
especially for complex objects:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">defmethod</span></i> checkl:result-translate <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">thing thing</span>)</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">thing-x thing</span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code">run <span class="keyword">:incr-thing</span></span>)</span> <span class="comment">;; =&gt; 0, 1, 2</span></div></code>

<p>This can be useful for checking selected values of deeply-nested
structures and objects.</p>

<h2>standard-object</h2>

<p>Another option for standard-object instances is to implement
<code>ms:class-persistant-slots</code> (sic).  <code>RESULT-TRANSLATE</code> calls
<code>marshal</code>/<code>unmarshal</code> on objects by default, which makes a copy,
if this method is defined.</p>

<p>This method must merely return a list of slot names, and is trivial to
implement.  <a href="https://github.com/wlbr/cl-marshal" >See the documentation for
<code>cl-marshal</code></a> for more details.</p>

<h2>Categories</h2>

<p>So you've been writing a bunch of little tests and want to run them
all and see if anything has changed:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">run-all</span>)</span></div></code>

<p>Easy!  And you haven't had to specifically declare it so in three
places.  However maybe you want a bit more structure and split up your
tests when you run them all.  Thus categories:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:foo</span> <span class="keyword">:category</span> <span class="keyword">:some-category</span></span>)</span> ...</span>)</span><br><br>
<span class="paren1">(<span class="code">run-all <span class="keyword">:some-category</span> ...</span>)</span></div></code>

<p>The default category is perhaps unsurprisingly called <code>:default</code>.
That's pretty much all there is to categories.</p>

<h2>Remembering results</h2>

<p>Since we're not <em>manually</em> defining the result, it would be
unfortunate if we <em>happened</em> to quit our lisp while our code still had
a bug, and then weren't sure what it was.  Easy enough:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">checkl-store <span class="string">"some-file"</span></span>)</span><br>
<span class="comment">;;; - later -<br>
</span><span class="paren1">(<span class="code">checkl-load <span class="string">"some-file"</span></span>)</span></div></code>

<p>This uses <code>cl-marshal</code> and <code>WRITE</code> to write values to the file
(overwriting it entirely).  <code>*PRINT-READABLY*</code> is forced to <code>t</code>, but
you can otherwise customize the output as per <code>WRITE</code>.</p>

<p>Along with revision control, it should be easy to keep track of test
results and make modifications.</p>

<h2>Formalizing</h2>

<p>This is not meant to be a complete replacement for test suites such as
FiveAM, but more of a &quot;deformalization&quot;.</p>

<p>But once you've worked on a bit of code and have your buffer cluttered
with <code>(check (...) ...)</code> forms, you probably don't want to rewrite
them all as FiveAM constructs.  It'd be nice if you could just sortof
integrate them all with minimal effort, like this:</p>

<code><div class="codeblock"><span class="comment">;; 5am doesn't have a find-suite, so you have to do this:<br>
</span><span class="paren1">(<span class="code"><i><span class="symbol">defsuite</span></i> <span class="keyword">:default</span></span>)</span><br><br>
<span class="paren1">(<span class="code">check-formal <span class="paren2">(<span class="code"><span class="keyword">:name</span> <span class="keyword">:two</span></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span></div></code>

<p>Well, assuming you had FiveAM loaded before you loaded CheckL, this is
exactly what you do.  (I didn't want FiveAM to be a strict
dependency.)  Now you can do one of these, and they still do what they
should:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">5am:run! <span class="keyword">:default</span></span>)</span> <span class="comment">;; =&gt; Pretty dots, one per VALUE<br>
</span><span class="paren1">(<span class="code">run-all <span class="keyword">:default</span></span>)</span> &nbsp;<span class="comment">;; =&gt; 2</span></div></code>

<p>We've gone from <em>very</em> informal testing to having things in FiveAM
with minimal effort!</p>

<p>Note that you can <em>still</em> eval the <code>CHECK-FORMAL</code> block in your buffer
and it behaves just like a <code>CHECK</code> block, returning its values and
signaling a condition if they change.</p>

<h2>ASDF</h2>

<p>Wouldn't it be nice if ASDF loaded your saved CheckL values, and let
you call your newly-created FiveAM tests with minimal effort?  Of
course!</p>

<code><div class="codeblock"><span class="paren1">(<span class="code"><i><span class="symbol">cl:eval-when</span></i> <span class="paren2">(<span class="code"><span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">asdf:load-system <span class="keyword">:fiveam</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class="code">asdf:load-system <span class="keyword">:checkl</span></span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code"><i><span class="symbol">defsystem</span></i> <span class="keyword">:my-system</span><br>&nbsp;&nbsp;<span class="keyword">:description</span> <span class="string">"A brand new system"</span><br>&nbsp;&nbsp;...</span>)</span><br><br>
<span class="paren1">(<span class="code"><i><span class="symbol">defsystem</span></i> <span class="keyword">:my-system-tests</span><br>&nbsp;&nbsp;<span class="keyword">:description</span> <span class="string">"A system that tests"</span><br>&nbsp;&nbsp;<br>&nbsp;&nbsp;<span class="keyword">:depends-on</span> <span class="paren2">(<span class="code"><span class="keyword">:fiveam</span> <span class="keyword">:checkl</span></span>)</span><br>&nbsp;&nbsp;<span class="keyword">:serial</span> t<br>&nbsp;&nbsp;<span class="keyword">:pathname</span> <span class="string">"t"</span><br><br>&nbsp;&nbsp;<span class="keyword">:components</span> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="keyword">:file</span> <span class="string">"package"</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class="code">checkl:tests <span class="string">"some-test"</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class="code">checkl:test-values <span class="string">"test-values"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:package</span> <span class="keyword">:my-system-tests</span></span>)</span></span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="code"><i><span class="symbol">checkl:define-test-op</span></i> <span class="keyword">:my-system</span> <span class="keyword">:my-system-test</span></span>)</span><br>
<span class="paren1">(<span class="code"><i><span class="symbol">checkl:define-test-op</span></i> <span class="keyword">:my-system-test</span></span>)</span></div></code>

<p>That's all!  No long <code>PERFORM</code> definitions.  Just make sure to have
the <code>EVAL-WHEN</code> at the top.  Now you can do this:</p>

<code><div class="codeblock"><span class="paren1">(<span class="code">asdf:load-system <span class="keyword">:my-system</span></span>)</span><br>
<span class="paren1">(<span class="code">asdf:test-system <span class="keyword">:my-system</span></span>)</span> <span class="comment">;; =&gt; (5am:run! :default)</span></div></code>

<p>Things of note:</p>

<ul>
<li><p>New ASDF component: <code>CHECK:TESTS</code> loads a file with <code>CHECK-FORMAL</code>
  tests, but does <em>not</em> run them.</p></li>
<li><p>New ASDF component: <code>CHECK:TEST-VALUES</code> loads a file with test
  values.  It also sets the path to be the <em>default</em> for test values,
  so you can simply do <code>(checkl-store)</code> or <code>(checkl-load)</code>.</p></li>
<li><p><code>define-test-op SYSTEM &amp;optional OTHER-SYSTEM</code>: This sets up the
  <code>ASDF:PERFORM</code> method for system to either run tests, or load
  another system and call <code>TEST-OP</code> on <em>it</em>.  If you're doing the
  latter, you need both definitions.</p></li>
</ul>

<h1>Etc</h1>

<p>I've been using this a bit and have added some conveniences.  There
could certainly be more.  Suggestions welcome, theoretical or
otherwise.</p>

<a name='REFERENCE-CHECKL'></a>
<h1>
  Reference: CHECKL
</h1>
<h2>
  Functions
</h2>
<a name='CHECKL-LOAD' class='apiref-row'></a>
<div class='apiref-spec'>CHECKL-LOAD
</div>
<div class='apiref-lambda'>(&OPTIONAL FILESPEC)
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>Load package test results from <code>FILESPEC</code></p>

</div>
<a name='CHECKL-STORE' class='apiref-row'></a>
<div class='apiref-spec'>CHECKL-STORE
</div>
<div class='apiref-lambda'>(&OPTIONAL FILESPEC)
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>Store package test results to <code>FILESPEC</code></p>

</div>
<a name='CLEAR' class='apiref-row'></a>
<div class='apiref-spec'>CLEAR
</div>
<div class='apiref-lambda'>(&REST NAMES)
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>Clear the test results from the tests <code>NAMES</code>.  For clearing anonymous
test results, see <code>CLEAR-ANONYMOUS</code>.</p>

</div>
<a name='CLEAR-ANONYMOUS' class='apiref-row'></a>
<div class='apiref-spec'>CLEAR-ANONYMOUS
</div>
<div class='apiref-lambda'>()
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>Clear anonymous test results.  For clearing named tests, see <code>CLEAR</code>.</p>

</div>
<a name='RESULT-EQUALP' class='apiref-row'></a>
<div class='apiref-spec'>RESULT-EQUALP
</div>
<div class='apiref-lambda'>(O1 O2)
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>Generic function to compare test results <code>O1</code> to
<code>O2</code>.  Defaults to <code>EQUALP</code>.</p>

</div>
<a name='RESULT-TRANSLATE' class='apiref-row'></a>
<div class='apiref-spec'>RESULT-TRANSLATE
</div>
<div class='apiref-lambda'>(RESULT)
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>RESULT-TRANSLATE is called on RESULT before calling
RESULT-EQUALP and before storing RESULT.  This defaults to RESULT, but
may be useful for converting more complex objects into simpler
objects.  For sequences and structures, COPY-SEQ and COPY-STRUCTURE
are called.  For STANDARD-OBJECT instances, (MS:UNMARSHAL (MS:MARSHAL
OBJECT)) is called.</p>

</div>
<a name='RUN' class='apiref-row'></a>
<div class='apiref-spec'>RUN
</div>
<div class='apiref-lambda'>(&REST NAMES)
</div>
<div class='apiref-result'>=> test-results
</div>
<div class='apiref-doc'>

<p>Run tests named <code>NAMES</code>, collecting their results.</p>

</div>
<a name='RUN-ALL' class='apiref-row'></a>
<div class='apiref-spec'>RUN-ALL
</div>
<div class='apiref-lambda'>(&OPTIONAL (CATEGORY :DEFAULT) &REST CATEGORIES)
</div>
<div class='apiref-result'>=> test-results
</div>
<div class='apiref-doc'>

<p>Run all tests, optionally specifying categories.</p>

</div>
<h2>
  Macros
</h2>
<a name='CHECK' class='apiref-row'></a>
<div class='apiref-spec'>CHECK
</div>
<div class='apiref-lambda'>((&KEY NAME (CATEGORY :DEFAULT) (OUTPUT-P NIL)) &BODY BODY)
</div>
<div class='apiref-result'>=> test-results
</div>
<div class='apiref-doc'>

<p>Run <code>BODY</code>.  Check resulting values against the last run using
<code>CHECKL:RESULT-EQUALP</code>, or store them if this is the first run.
Sameness of the test is determined by comparing the body with
<code>EQUALP</code>, or by <code>NAME</code>.</p>

<p><code>NAME</code> may be specified to name a test.  If the test exists but is
anonymous (i.e., <code>NAME</code> has not been specified), specifying <code>NAME</code>
will name the test and it will no longer be anonymous.</p>

<p><code>CATEGORY</code> may be specified for running groups of tests.</p>

<p>If <code>OUTPUT-P</code> is <code>t</code>, the results will be printed to
<code>*standard-output*</code> as well as returned.  This may be helpful if the
results are too long to see in your emacs minibuffer.</p>

</div>
<a name='CHECK-OUTPUT' class='apiref-row'></a>
<div class='apiref-spec'>CHECK-OUTPUT
</div>
<div class='apiref-lambda'>(&BODY BODY)
</div>
<div class='apiref-result'>
</div>
<div class='apiref-doc'>

<p>Use this within a <code>CHECK</code> block.  Rebind <code>*standard-output*</code> and
<code>*error-output*</code> and return a <code>CHECK</code>-able result.</p>

</div>
<a name='RESULTS' class='apiref-row'></a>
<div class='apiref-spec'>RESULTS
</div>
<div class='apiref-lambda'>(&REST VALUES)
</div>
<div class='apiref-result'>=> VALUES
</div>
<div class='apiref-doc'>

<p>This will evaluate each subform in order and call RESULT-TRANSLATE on
the result.  This is especially useful if subforms repeatedly modify
and return the object, e.g. <code>(results (incf *x*) (incf *x*))</code></p>

</div>
</html>